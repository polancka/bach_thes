import 'package:bach_thes/components/personal_button.dart';
import 'package:bach_thes/components/text_field.dart';
import 'package:bach_thes/pages/home_page.dart';
import 'package:flutter/material.dart';

class RegistrationPage extends StatefulWidget {
  const RegistrationPage({Key? key}) : super(key: key);

  @override
  _RegistrationPage createState() => _RegistrationPageState();
}

class _RegistrationPageState extends State<RegistrationPage>{
  @override
  Widget buil(BuildContext context){
    return Scaffold(
        backgroundColor: Colors.white,
        body: SafeArea(
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  "Register now!",
                  style: TextStyle(
                      color: Colors.black,
                      fontSize: 25,
                      fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 5),
                /*PersonalizedTextInputField(
                    hintText: "Name",
                    obscureText: false,
                    controller: nameController),
                const SizedBox(height: 3),
                PersonalizedTextInputField(
                    hintText: "Email",
                    obscureText: false,
                    controller: emailController),
                const SizedBox(height: 3),
                PersonalizedTextInputField(
                    hintText: "Set password",
                    obscureText: true,
                    controller: passwordController),*/
                const SizedBox(height: 3),

                GestureDetector(
                    onTap: () {
                      Navigator.push(context,
                          MaterialPageRoute(builder: (context) => HomePage()));
                    },
                    child: const Text("Register now!")),

                //PersonalButton(text: "Register", onTap: RegisterUser())
              ],
            ),
          ),
        ));
  }
}
  //final nameController = TextEditingController();
  //final emailController = TextEditingController();
  //final passwordController = TextEditingController();

  /*RegisterUser(ContextMenuButtonItem context) {GestureDetector(
                  onTap: () {
                    Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) => RegistrationPage()));
                  },
                  child: const Text(
                    "Not a member yet? Sign up here!",
                    style: TextStyle(fontWeight: FontWeight.w500),
                  ),
                )

  }*/




-----------------------
Navigator.push(context,
                          MaterialPageRoute(builder: (context) => HomePage()));
                    },
.--------------------------------
OLD LOGIN PAGE 
//the login page, where user inputs his email and password and signs in the application
//user can also sign in with appleId or googleId
//or he can register if they are not using the application already


import 'package:bach_thes/components/personal_button.dart';
import 'package:bach_thes/components/text_field.dart';
//import 'package:bach_thes/pages/authentication_page.dart';
import 'package:bach_thes/pages/home_page.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:bach_thes/components/square_tile.dart';
//import 'package:firebase_auth/firebase_auth.dart';
import 'registration_page.dart';

class LoginPage extends StatefulWidget {
  LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  // text editing controllers

  final emailController = TextEditingController();
  final passwordController = TextEditingController();

  void signUserIn() async {
    await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: emailController.text, password: passwordController.text);
  }

  //build function
  @override
  Widget build(BuildContext context) {
    return Scaffold(
        backgroundColor: Color.fromARGB(255, 197, 202, 204),
        body: SafeArea(
          child: Center(
              child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                //the main elements of the login page
                //logo
                SquareTile(imageUrl: 'lib/images/gore.png'),

                const SizedBox(
                  height: 20,
                ),

                // email textbox
                PersonalizedTextInputField(
                  hintText: 'Enter your email',
                  obscureText: false,
                  controller: emailController,
                ),

                const SizedBox(
                  height: 20,
                ),

                //password textbox
                PersonalizedTextInputField(
                  hintText: 'Enter your password',
                  obscureText: true,
                  controller: passwordController,
                ),

                const SizedBox(
                  height: 10,
                ),

                //forgot password?
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 25.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      Text(
                        'Forgot Password?',
                        style: TextStyle(color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),

                const SizedBox(
                  height: 10,
                ),

                //sign in button with function to sign the user in
                PersonalButton(text: "Sign in", onTap: _navigateToHomePage(context)),

                const SizedBox(
                  height: 20,
                ),

          
                //Not a member yet? Sign up!
                GestureDetector(
                  onTap: () {
                    _navigateToRegistrationPage(context);
                  },
                  child: const Text(
                    "Not a member yet? Sign up here!",
                    style: TextStyle(fontWeight: FontWeight.w500),
                  ),
                )
              ])),
        ));
  }
}

void _navigateToRegistrationPage(BuildContext context) {
  Navigator.of(context)
      .push(MaterialPageRoute(builder: (context) => RegistrationPage()));
}

void _navigateToHomePage(BuildContext context) {
  Navigator.of(context)
      .push(MaterialPageRoute(builder: (context) => HomePage()));
}
_____________________________________________________________________________________
Another way of navigating pages
 {
                WidgetsBinding.instance!.addPostFrameCallback((_) {
                  Navigator.pushReplacement(
                      context, MaterialPageRoute(builder: (_) => HomePage()));
                });
              }

_____________________________________________________________________________________
Personalized text fields 

Align reusableTextFieldEmail(String hinttext, TextEditingController controller,
    bool isPassword, IconData icon) {
  return Align(
      alignment: Alignment.center,
      child: TextFormField(
        keyboardType: TextInputType.emailAddress,
        style: TextStyle(
          color: Colors.white,
        ),
        controller: controller,
        obscureText: isPassword,
        decoration: InputDecoration(
          prefixIcon: Icon(
            icon,
            color: Colors.white,
          ),
          labelText: hinttext,
          filled: true,
          floatingLabelBehavior: FloatingLabelBehavior.never,
          fillColor: Colors.white.withOpacity(0.3),
          labelStyle: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w400,
          ),
          border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(20.0),
              borderSide: BorderSide(width: 0, style: BorderStyle.none)),
        ),
      ));
}

Align reusableTextFieldPassword(String hinttext,
    TextEditingController controller, bool isPassword, IconData icon) {
  return Align(
      alignment: Alignment.center,
      child: TextFormField(
        validator: (value) {
          if (value == null ||
              value.isEmpty ||
              !value.contains('@') ||
              !value.contains('.')) {
            return 'Invalid Email';
          }
          return null;
        },
        style: TextStyle(
          color: Colors.white,
        ),
        controller: controller,
        obscureText: isPassword,
        decoration: InputDecoration(
          prefixIcon: Icon(
            icon,
            color: Colors.white,
          ),
          labelText: hinttext,
          filled: true,
          floatingLabelBehavior: FloatingLabelBehavior.never,
          fillColor: Colors.white.withOpacity(0.3),
          labelStyle: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w400,
          ),
          border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(20.0),
              borderSide: BorderSide(width: 0, style: BorderStyle.none)),
        ),
      ));
}
------------------------------------------------
registration as statefull widgetsclass RegistrationPage extends StatefulWidget {
  final RegistrationController controller;
  final RegistrationModel model;
  const RegistrationPage(
      {super.key, required this.controller, required this.model});

  @override
  State<RegistrationPage> createState() => _RegistrationPageState();
}

class _RegistrationPageState extends State<RegistrationPage> {
  TextEditingController newNameController = TextEditingController();
  TextEditingController newEmailController = TextEditingController();
  TextEditingController newPasswordController = TextEditingController();
  -------------------------------------------
  Search peaks build method that worked (retrieving from mock database)

  import 'package:bach_thes/models/peak.dart';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:bach_thes/models/mock_database/mock_peak.dart';
import 'package:bach_thes/globals.dart';

class SearchPeaks extends StatelessWidget {
  const SearchPeaks({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
        child: Scaffold(
            backgroundColor: Colors.pink,
            appBar: AppBar(
              backgroundColor: Colors.white,
              title: Text(
                "Search Slovenian peaks",
                style: TextStyle(color: Colors.pinkAccent),
              ),
            ),
            body: Container(
                child: ListView.separated(
                    itemCount: MockPeak.FetchAll().length,
                    itemBuilder: (context, index) =>
                        _buildListItem(context, MockPeak.FetchAll()[index]),
                    separatorBuilder: (context, index) => SizedBox(
                          height: 10,
                        )))));
  }
}

Widget _buildListItem(BuildContext context, Peak peak) {
  return Container(
      padding: EdgeInsets.all(10),
      decoration: BoxDecoration(
          color: Colors.white, borderRadius: BorderRadius.circular(20)),
      child: ListTile(
        leading: Icon(Icons.hiking_outlined),
        title: Text("${peak.name},  ${peak.altitude}m"),
        subtitle: Text(peak.description),
        trailing: Icon(Icons.keyboard_double_arrow_right_outlined),
      ));
}
.---------------------------------------------------------
FUNCTIONAL LIST OF PEAKS (READING FROM MOCK DATABASE)
import 'package:bach_thes/models/peak.dart';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:bach_thes/models/mock_database/mock_peak.dart';
import 'package:bach_thes/globals.dart';
import 'package:bach_thes/controllers/list_of_peaks_controller.dart';


//UI for the list of peaks shown during search (?) function

class SearchPeaks extends StatelessWidget {
  const SearchPeaks({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        backgroundColor: Colors.pinkAccent,
        appBar: AppBar(
          backgroundColor: Colors.pinkAccent,
          title: Text(
            "Search Slovenian peaks",
            style: TextStyle(color: Colors.white),
          ),
        ),
        body: Padding(
          padding: const EdgeInsets.all(8.0),
          child: Container(
              child: ListView.separated(
                  itemCount: MockPeak.FetchAll().length,
                  itemBuilder: (context, index) =>
                      buildListItem(context, MockPeak.FetchAll()[index]),
                  separatorBuilder: (context, index) => const SizedBox(
                        height: 10,
                      ))),
        ));
  }
}
------------------------------
delujoč streambuilder za prikaz peaksov 
child: StreamBuilder(
                    stream: db.collection('Peaks').snapshots(),
                    builder: (context, snapshot) {
                      if (!snapshot.hasData) {
                        return const Text("Loading ...");
                      }

                      //log(snapshot.data!.docs[1].//get('altitude').toString());
                      return ListView.separated(
                          separatorBuilder: ((context, index) =>
                              const SizedBox(height: 10)),
                          itemCount: snapshot.data!.docs.length,
                          itemBuilder: (context, index) => buildListItem(
                              context, snapshot.data!.docs[index]));
                    },
-----------------------------
checki if has paths
 /*try {
    result.addAll(renderPaths(context, document));
  } on FirebaseFirestore catch (e) {
    print(e);
  }*/
------------------
findPaths(String name) async {
  var paths = await FirebaseFirestore.instance
      .collection('Paths')
      .where('finishPointName', isEqualTo: name)
      .get();

  return paths.docs.first['name'];
}
---------------------
working function for displaying paths with jsonDecode/*List<Widget> renderPaths(BuildContext context, DocumentSnapshot document) {
  final arrayOfPaths = document['Paths'];

  var result = <Widget>[];

  for (int i = 0; i < document['Paths'].length; i++) {
    var firstPath = arrayOfPaths[i].toString();
    Map<String, dynamic> jsonPath = jsonDecode(firstPath);

    //TODO: make a new Path for every path, this path is then sent
    Path path = Path(
        id: jsonPath['id'],
        pathName: jsonPath['pathName'],
        startingPointName: jsonPath['StartingPointName'],
        startingPointId: jsonPath['startingPointId'],
        startingPointAltitude: jsonPath['startingPointAltitude'],
        finishPointName: jsonPath['finishPointName'],
        alitmeters: jsonPath['altimeters'],
        altimetersOnTheWay: jsonPath['altimetersOnTheWay'],
        difficulty: jsonPath['difficulty'],
        duration: jsonPath['duration'],
        description: jsonPath['description'],
        recommendedEquipment: jsonPath['recommendedEquipment']);
    result.add(ListTile(
        //shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        //selectedTileColor: Colors.white,
        tileColor: Colors.black,
        dense: true,
        leading: Icon(Icons.nordic_walking_outlined),
        title: Text("${jsonPath['StartingPointName']}"),
        subtitle: Text("Chose this path"),
        trailing: Icon(Icons.keyboard_double_arrow_right_outlined),
        onTap: () => navigateToPathDetail(context, path)));
  }

  return result;

  /*return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
      ),
      child: Padding(
          padding: EdgeInsets.all(20),
          child: Column(
            children: [
              Text("${arrayOfPaths[0]}"),
              SizedBox(height: 10),
              Text("${arrayOfPaths[1]}"),
            ],
          )));*/
}*/
---------------------
nek low effort
Future<List<Widget>> renderPathsTwo(
    BuildContext context, DocumentSnapshot document) async {
  var result = <Widget>[];

  var paths = await FirebaseFirestore.instance
      .collection('Paths')
      .where('finishPointName', isEqualTo: document['name'])
      .get();

  result.add(ListTile(
      //shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      //selectedTileColor: Colors.white,
      tileColor: Colors.black,
      dense: true,
      leading: Icon(Icons.nordic_walking_outlined),
      title: Text("Test"),
      subtitle: Text("Chose this path"),
      trailing: Icon(Icons.keyboard_double_arrow_right_outlined),
      onTap: () => {}));

  return result;
}
----------------
another effort of rendering paths/*List<ListTile> renderPeakPaths(BuildContext context, DocumentSnapshot document) {
  var result = List<ListTile>.empty(growable: true);
  for (int i = 0; i < document['possiblePaths'].length; i++) {
    result.add(ListTile(
      leading: Icon(Icons.nordic_walking_outlined),
      title: Text(
          "${peak.possiblePaths[i].startingPointName},  ${peak.possiblePaths[i].duration}"),
      subtitle: Text(peak.altitude.toString()),
      trailing: Icon(Icons.keyboard_double_arrow_right_outlined),
      onTap: () => navigateToPathDetail(context, document.possiblePaths[i]),
    ));
  }

  final result = <Widget>[];


  for (int i = 0; i < peak.possiblePaths.length; i++) {
    result.add(sectionTitle(
        "From starting point no. ${peak.possiblePaths[i].startingPointId}"));
    result.add(sectionText(peak.possiblePaths[i].description));
  }

  return result;
}*/
--------------------------------
Card for list peak/ paths
Container(
      child: Card(
          margin: EdgeInsets.all(3),
          color: Styles.deepgreen.withOpacity(0.7),
          shape: ContinuousRectangleBorder(
              borderRadius: BorderRadius.circular(20)),
          child: ListTile(
            leading: Icon(
              Icons.hiking_outlined,
              color: Colors.white,
            ),
            title: Text(
              pathInfo[0],
              style: TextStyle(color: Colors.white),
            ),
            subtitle: Text(pathInfo[1], style: TextStyle(color: Colors.white)),
            trailing: Icon(
              Icons.keyboard_double_arrow_right_outlined,
              color: Colors.white,
            ),
            onTap: () => MyNavigator(context).NavigateToHome(),
          )));
-----------------------------------
realtime getting data from FirebaseFirestoreWidget build(BuildContext context) {
  return new StreamBuilder(
      stream: Firestore.instance.collection('COLLECTION_NAME').document('TESTID1').snapshots(),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return new Text("Loading");
        }
        var userDocument = snapshot.data;
        return new Text(userDocument["name"]);
      }
  );
}
----------------------------
old profile page (late initalization error)
import 'package:bach_thes/controllers/profile_page_controller.dart';
import 'package:bach_thes/models/current_user.dart';
import 'package:bach_thes/models/hike.dart';
import 'package:bach_thes/models/hiker.dart';
import 'package:bach_thes/views/widgets/booklet_widget.dart';
import 'package:bach_thes/views/widgets/mountain_card.dart';
import 'package:bach_thes/views/widgets/reusable_widgets.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:bach_thes/utils/styles.dart';
import 'package:percent_indicator/percent_indicator.dart';
import 'package:bach_thes/views/widgets/hike_card.dart';
import 'main_page.dart';
import 'package:bach_thes/models/hiker.dart';
import 'package:bach_thes/globals.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;

/* UI for showing users profile page. it shows their picture, username, 
level, number of points on a progress bar and their booklet. The booklet itself
 consists of recorderd hikes and achieved peaks and badges. Both parts of the 
 booklet are clickable. They lead to new pages with all possible peaks.*/

class ProfilePage extends StatefulWidget {
  @override
  State<ProfilePage> createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  var currentUserTwo = FirebaseAuth.instance.currentUser?.uid.toString();
  late Future<Album> fetchTriglavJSON;
  List recentHikes = [];

  final List achievedPeaks = [];

  final List achievedBadges = [];

  String percentProgress = '';
  double decimalProgress = 0.0;

  returnListHikes(String? currentUserTwo) async {
    var recordedHikesQuery = await FirebaseFirestore.instance
        .collection('RecordedHikes')
        .where('hikerId', isEqualTo: currentUserTwo)
        .get();

    setState(() {
      recentHikes = List.from(recordedHikesQuery.docs);
    });
    //print(recentHikes);
  }

  String returnPercentProgress() {
    //returns the percentage in 20% form
    String percentprogres = '';
    int remaining = int.parse(currentHiker.points) % 100;
    percentprogres = remaining.toString();
    return percentprogres;
  }

  double returnDecimalProgress() {
    double decimalProgress = 0.0;
    int remaining = int.parse(currentHiker.points) % 100;
    decimalProgress = remaining / 100;
    return decimalProgress;
  }

  getHiker() async {
    var profiles = await FirebaseFirestore.instance
        .collection('Hikers')
        .where('id', isEqualTo: currentUserTwo)
        .get();
    var profilestwo = profiles.docs;
    for (var userSnapshot in profilestwo) {
      setState(() {
        print("getting hiker");
        currentHiker = Hiker(
            id: userSnapshot['id'].toString(),
            username: userSnapshot['username'].toString(),
            email: userSnapshot['email'].toString(),
            profilePicture: userSnapshot['pictureUrl'].toString(),
            level: userSnapshot['level'].toString(),
            points: userSnapshot['points'],
            bookletId: userSnapshot['bookletId'].toString(),
            scoreboardParticipation:
                userSnapshot['scoreboardParticipation'].toString(),
            achievedPeaks: List.from(userSnapshot['achievedPeaks']),
            numberOfHikes: userSnapshot['numberOfHikes'],
            timeTogheter: userSnapshot['timeTogheter'],
            altimetersTogheter: userSnapshot['altimetersTogheter']);
      });
    }
  }

  @override
  void initState() {
    getHiker();

    var newHiker = TestHiker(1, "Ana");
    returnListHikes(currentUserTwo);
    setState(() {
      percentProgress = returnPercentProgress();
      decimalProgress = returnDecimalProgress();
    });
    fetchTriglavJSON = fetchTriglav();
    super.initState();
  }

  Future<Album> fetchTriglav() async {
    final response =
        await http.get(Uri.parse('https://mapzs.pzs.si/api/pois/1'));
    if (response.statusCode == 200) {
      // If the server did return a 200 OK response,
      // then parse the JSON.
      return Album.fromJson(jsonDecode(response.body));
    } else {
      // If the server did not return a 200 OK response,
      // then throw an exception.
      throw Exception('Failed to load album');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        body: Column(
      children: [
        SizedBox(
          height: 25,
        ),
        FutureBuilder<Album>(
          future: fetchTriglavJSON,
          builder: (context, snapshot) {
            if (snapshot.hasData) {
              return Text(snapshot.data!.name);
            } else if (snapshot.hasError) {
              return Text('${snapshot.error}');
            }

            // By default, show a loading spinner.
            return const CircularProgressIndicator();
          },
        ),
        CircleAvatar(
            backgroundColor: Styles.lightgreen,
            radius: 50,
            child: CircleAvatar(
              backgroundColor: Colors.white,
              backgroundImage: AssetImage('lib/utils/images/user_logo.png'),
              radius: 40,
            )),
        //logoWidget(currentHiker.profilePicture),
        SizedBox(
          height: 20,
        ),
        Center(
            child: Container(
          child: Text("${currentHiker.username}", style: Styles.headerLarge),
        )),
        SizedBox(
          height: 20,
        ),
        //level
        Center(
            child: Container(
          child: Text("Level ${currentHiker.level}",
              style: TextStyle(fontSize: 15)),
        )),

        SizedBox(height: 10),
        Center(
            child: Container(
          child: Text("${currentHiker.points}/${currentHiker.level}00 points",
              style: TextStyle(fontSize: 15)),
        )),

        //progress bar with points
        Padding(
          padding: EdgeInsets.all(15.0),
          child: LinearPercentIndicator(
            width: MediaQuery.of(context).size.width - 50,
            animation: true,
            lineHeight: 20.0,
            animationDuration: 2500,
            percent: decimalProgress,
            center: Text("${percentProgress}%",
                style: TextStyle(color: Colors.white)),
            barRadius: Radius.circular(20),
            progressColor: Styles.deepgreen,
          ),
        ),
        SizedBox(
          height: 25,
        ),
        Center(
            child:
                Text("My most recent hikes", style: TextStyle(fontSize: 18))),

        //most recent hikes (top 3 or display "You don't have any recent hikes yet")
        Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Container(
              width: MediaQuery.of(context).size.width * 0.9,
              decoration: BoxDecoration(
                color: Styles.offwhite,
                borderRadius: BorderRadius.circular(20),
              ),
              child: Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Column(
                    children: renderLatestHikes(recentHikes),
                  )),
            ),
          ),
        )
      ],
    ));
  }
}

class Album {
  final int id;
  final String name;

  const Album({
    required this.id,
    required this.name,
  });

  factory Album.fromJson(Map<String, dynamic> json) {
    return Album(id: json['id'], name: json['name']);
  }
}

/*getHikerInfo() async {
  var currentUserOne = FirebaseAuth.instance.currentUser?.uid.toString();
  var data = FirebaseFirestore.instance
      .collection('Hikers')
      .where('id', isEqualTo: currentUserOne);

  String usernamee = data.get('email' as GetOptions?).toString();

  //Hiker currentHiker
}

Future<QuerySnapshot> getHikerData() async {
  var currentUserOne = FirebaseAuth.instance.currentUser?.uid.toString();
  return await FirebaseFirestore.instance
      .collection("Hikers")
      .where('id', isEqualTo: currentUserOne)
      .get();
}*/

/*return Scaffold(
      body: Column(
        children: [
          //background top picture
          Image.asset("lib/utils/images/profile_back.png"),
          SizedBox(height: 20),
          //user avatar
          //usrt name
          //user level
          //user progress bar with points
          //user Booklet (user id)
          BookletWidget()
        ],
      ),
    );*/

class TestHiker {
  int id;
  String name;

  TestHiker(this.id, this.name);

  int getHikerId() {
    return this.id;
  }

  String getHikerName() {
    return this.name;
  }
}
------------------------------
old recording page (no chatgpt)
import 'dart:async';
import 'package:bach_thes/controllers/navigation_controller.dart';
import 'package:bach_thes/views/widgets/reusable_widgets.dart';
import 'package:flutter/material.dart';
import 'package:location/location.dart';
import 'package:bach_thes/utils/styles.dart';
import 'package:bach_thes/models/hike.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:background_location/background_location.dart';
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter_background/flutter_background.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

class RecordingPage extends StatefulWidget {
  const RecordingPage({super.key});

  @override
  State<RecordingPage> createState() => _RecordingPageState();
}

class _RecordingPageState extends State<RecordingPage>
    with WidgetsBindingObserver {
  AppLifecycleState? _notification;
  double? longitude = 0.0;
  double? latitude = 0.0;
  double altimetersDone = 1;
  int secondsElapsed = 1;
  late Duration duration;
  var buttonText;
  var isRecording = false;
  final timeStamp = DateTime.now();
  var endPointName = "";
  var currentId;
  var altBeg;
  var altMid;
  var altFin;
  late DateTime secBeg;
  late DateTime secMid;
  late DateTime secFin;
  bool isCurrentlyRecording = false;
  var beginAltimeters;
  var finishAltimeters;

  Stopwatch _stopwatch = Stopwatch();
  late Timer _timer;

  //TODO: figure out the date and time, figure out counting seconds and altimeters
  //TODO: why is location wrong, locking the textfield after "start recording"
  //tracking geopoints and saving them?

  //when u input name, lock the field, or have a dropdown menu to choose from all peaks
  TextEditingController endPointNameController = new TextEditingController();

  int calculatePoints(int miliseconds) {
    //hike must last more than 10minutes
    //if (miliseconds < 600000) {
    //return 0;
    //}
    var pointsToAdd = 10; //10 points for recording a hike
    pointsToAdd = pointsToAdd +
        (altimetersDone.floor() % 100) * 2; // 2 points for every 100 altimeters
    pointsToAdd = pointsToAdd +
        (secondsElapsed % 60) * 5; // 5 points for every hour of hiking

    return pointsToAdd;
  }

  checkIfRecording() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      isCurrentlyRecording = prefs.getBool('isRecording')!;
    });
  }

  calculateTimerToShow() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    //implement logic for calculating the correct time on screen
    duration = DateTime.now().difference(secBeg);
    print(duration);
  }

  String formatTime(int milliseconds) {
    var secs = milliseconds ~/ 1000;
    var hours = (secs ~/ 3600).toString().padLeft(2, '0');
    var minutes = ((secs % 3600) ~/ 60).toString().padLeft(2, '0');
    var seconds = (secs % 60).toString().padLeft(2, '0');
    return "$hours:$minutes:$seconds";
  }

  getUserId() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    currentId = FirebaseAuth.instance.currentUser!.uid;
    setState() {
      prefs.setString('id', currentId);
    }
  }

  stopRecording() async {
    _stopwatch.stop();
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      isRecording = false;
      endPointName = endPointNameController.text;
      secFin = DateTime.now();
    });
    prefs.setBool('isRecording', false);
    //cTODO: check if last location is near a peak in the database

    //calculate altimeters done
    //var finishAltimeters = await getCurrentPosition();
    //altimetersDone = finishAltimeters - beginAltimeters;
    //save to database under correct ID
    addNewRecordedHike(currentId, DateTime.now(),
        _stopwatch.elapsedMilliseconds ~/ 1000, 200, endPointName);

    //calculate points to add
    var earnedPoints = calculatePoints(_stopwatch.elapsedMilliseconds);

    //navigate to screen with congrats  --> there the new poitns are added to the database
    MyNavigator(context).navigateToPointsPage("recording a hike", earnedPoints);

    //return back to profile page
    _stopwatch.reset();
  }

  startRecording() async {
    _stopwatch.start();
    setState(() {
      //beginAltimeters = getCurrentPosition();
      secBeg = DateTime.now();
      isRecording = true;
    });
    SharedPreferences prefs = await SharedPreferences.getInstance();
    prefs.setInt('secBeg', secBeg.microsecondsSinceEpoch);
    prefs.setBool('isRecording', true);
    print(prefs.getInt('secBeg'));
    setBackgroundNotification();
    getLocationUpdates();
  }

  setBackgroundNotification() {
    BackgroundLocation.setAndroidNotification(
      title: "Hiking app",
      message: "You are currently recording a hike",
      icon: Image.asset("lib/utils/images/gore.png").toString(),
    );
  }

  getLocationUpdates() {
    BackgroundLocation.setAndroidConfiguration(1000);
    //here u define how many meters should pass for update
    BackgroundLocation.startLocationService(forceAndroidLocationManager: true);
    BackgroundLocation.getLocationUpdates((location) {
      print(location);
    });
  }

  /*Future<double> getCurrentPosition() async {
    Location location = Location();
    LocationData _locationData;
    bool serviceEnabled;
    PermissionStatus permission;

    // Test if location services are enabled.
    serviceEnabled = await location.serviceEnabled();
    if (!serviceEnabled) {
      return Future.error('Location services are disabled.');
    }

    permission = await location.hasPermission();
    if (permission == PermissionStatus.denied) {
      permission = await location.requestPermission();
      if (permission != PermissionStatus.granted) {
        //return nothing
      }
    }

    _locationData = await location.getLocation();
    setState(() {
      longitude = _locationData.longitude;
      latitude = _locationData.latitude;
    });
    //print("${longitude}-----${latitude}--------");

    return _locationData.altitude!;
  }*/

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    setState(() {
      _notification = state;
    });
  }

  @override
  void initState() {
    _stopwatch = Stopwatch();
    _timer = new Timer.periodic(new Duration(milliseconds: 30), (timer) {
      setState(() {});
    });

    //if we are already recording (isrecording is true in shared preferences), save the date and calulctae what to show
    checkIfRecording();
    if (isCurrentlyRecording) {
      setState(() {
        secMid = DateTime.now();
      });
    }
    getUserId();
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    _timer.cancel();
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: myAppBar("Hike recording"),
        body: Container(
          decoration: BoxDecoration(color: Colors.white),
          width: MediaQuery.of(context).size.width,
          child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Center(child: Text("Where are we hiking to?")),
                Padding(
                    padding: EdgeInsets.all(20),
                    child: TextField(controller: endPointNameController)),
                SizedBox(height: 25),
                Container(
                    child: isRecording
                        ? Image.asset("lib/utils/images/Hiker.gif",
                            height: 125.0, width: 125)
                        : Text("")),
                Text("Current position: ${longitude}, ${latitude} "),
                Text(formatTime(_stopwatch.elapsedMilliseconds)),
                Text("Altimeters done: ${altimetersDone}"),
                SizedBox(
                  height: 40,
                ),
                TextButton(
                  style: ButtonStyle(
                      backgroundColor: MaterialStateColor.resolveWith(
                          (states) => Styles.deepgreen)),
                  onPressed: () {
                    isRecording ? stopRecording() : startRecording();
                  },
                  child: isRecording
                      ? Text("Stop recording",
                          style: TextStyle(color: Colors.white))
                      : Text("Start recording",
                          style: TextStyle(color: Colors.white)),
                ),
              ]),
        ));
  }
}

------------------
Widget myMap(List<LatLng> points) {
  if (points.isEmpty) {
    return Text('No location points found for this hike.');
  }

  return FlutterMap(
    options: MapOptions(
      center: points.first,
      zoom: 15.0,
    ),
    children: [
      TileLayer(
        urlTemplate: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        subdomains: ['a', 'b', 'c'],
      ),
      PolylineLayer(
        polylines: [
          Polyline(
            points: points,
            color: Colors.blue,
            strokeWidth: 3.0,
          ),
        ],
      ),
      MarkerLayer(
        markers: [
          Marker(
            point: points.last,
            builder: (ctx) => Icon(Icons.location_on, color: Colors.red),
          ),
        ],
      ),
    ],
  );
}

